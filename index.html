<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è³‡å®‰èˆ‡æ•¸ä½å¹³æ¬Š - ç²’å­äº’å‹•æ¸¬é©—</title>

    <!-- Meta Tags for GitHub/SEO -->
    <meta name="description" content="äº’å‹•å¼è³‡å®‰èˆ‡æ•¸ä½å¹³æ¬Šæ¸¬é©—ï¼Œçµåˆ MediaPipe æ‰‹å‹¢è¾¨è­˜æŠ€è¡“ã€‚">
    <meta property="og:title" content="è³‡å®‰èˆ‡æ•¸ä½å¹³æ¬Š - ç²’å­äº’å‹•æ¸¬é©—">
    <meta property="og:description" content="ä½¿ç”¨æ‰‹å‹¢æ§åˆ¶çš„ç¾ä»£åŒ–ç¶²é éŠæˆ²ï¼Œå­¸ç¿’è³‡å®‰çŸ¥è­˜ã€‚">
    <meta property="og:type" content="website">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;500;700&family=Orbitron:wght@500&display=swap"
        rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary: #00f2ff;
            --correct: #00ff88;
            --wrong: #ff0055;
            --bg-glass: rgba(10, 20, 30, 0.85);
            --border: rgba(255, 255, 255, 0.2);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Noto Sans TC', sans-serif;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            z-index: 10;
        }

        /* --- é ‚éƒ¨ç‹€æ…‹åˆ— --- */
        .status-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 20px 40px;
            box-sizing: border-box;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
        }

        .life-container {
            font-size: 1.5rem;
            color: #ff3333;
        }

        .score-container {
            text-align: right;
        }

        .score-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 2px;
        }

        .score-value {
            font-size: 2rem;
            color: #fff;
            font-weight: bold;
        }

        .combo-text {
            font-size: 1rem;
            color: #ffcc00;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .combo-text.visible {
            opacity: 1;
        }

        /* --- é¡Œç›®å€ --- */
        #question-box {
            margin-top: 10px;
            background: var(--bg-glass);
            backdrop-filter: blur(12px);
            padding: 30px 50px;
            border-radius: 16px;
            border: 1px solid var(--primary);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
            text-align: center;
            max-width: 800px;
            width: 90%;
            transform: translateY(-50px);
            opacity: 0;
            transition: all 0.5s;
        }

        #question-box.visible {
            transform: translateY(0);
            opacity: 1;
        }

        #question-text {
            color: #fff;
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        /* --- é¸é …å€ --- */
        #answers-container {
            margin-top: auto;
            margin-bottom: 50px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            width: 80%;
            max-width: 1000px;
        }

        .answer-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            color: #fff;
            font-size: 1.4rem;
            position: relative;
            transition: all 0.3s;
            overflow: hidden;
        }

        .option-num {
            position: absolute;
            top: 10px;
            left: 15px;
            font-family: 'Orbitron', sans-serif;
            color: rgba(255, 255, 255, 0.3);
            font-size: 1rem;
        }

        .fill-overlay {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 0%;
            background: rgba(0, 242, 255, 0.2);
            z-index: -1;
            transition: width 0.1s linear;
        }

        .answer-card.hovering {
            border-color: var(--primary);
            box-shadow: 0 0 15px var(--primary);
            transform: scale(1.02);
        }

        .answer-card.correct {
            border-color: var(--correct);
            background: rgba(0, 255, 136, 0.2);
            box-shadow: 0 0 30px var(--correct);
        }

        .answer-card.wrong {
            border-color: var(--wrong);
            background: rgba(255, 0, 85, 0.2);
        }

        /* --- è¦–çª—: è©³è§£ & çµç®— --- */
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid var(--border);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
            z-index: 100;
        }

        .modal.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        /* è©³è§£å°ˆç”¨ */
        #feedback-modal.correct-mode {
            border-color: var(--correct);
        }

        #feedback-modal.wrong-mode {
            border-color: var(--wrong);
        }

        /* çµç®—å°ˆç”¨ */
        #gameover-modal {
            border-color: var(--primary);
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.3);
        }

        .modal-title {
            font-size: 2rem;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .modal-content {
            font-size: 1.2rem;
            color: #ddd;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        /* é‡ç©æŒ‰éˆ• (æ‰‹å‹¢äº’å‹•ç”¨) */
        .restart-btn {
            display: inline-block;
            margin-top: 20px;
            padding: 15px 40px;
            border: 2px solid #fff;
            border-radius: 50px;
            font-size: 1.5rem;
            color: #fff;
            position: relative;
            overflow: hidden;
        }

        .restart-btn .fill-overlay {
            background: rgba(255, 255, 255, 0.3);
        }

        /* æ”å½±æ©Ÿé è¦½è¦–çª— */
        #input-video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            object-fit: cover;
            /* è£åˆ‡æˆæ­£æ–¹å½¢ */
            border-radius: 12px;
            border: 2px solid rgba(0, 242, 255, 0.5);
            z-index: 50;
            transform: scaleX(-1);
            /* é¡åƒç¿»è½‰ */
            opacity: 0.8;
            transition: opacity 0.3s;
        }

        #input-video:hover {
            opacity: 1;
        }

        /* Help é€£çµæ¨£å¼ */
        .help-link {
            position: absolute;
            top: 20px;
            right: 40px;
            color: var(--primary);
            text-decoration: none;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            border: 1px solid var(--primary);
            padding: 5px 15px;
            border-radius: 20px;
            transition: all 0.3s;
            pointer-events: auto;
            z-index: 100;
        }

        .help-link:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 15px var(--primary);
        }
    </style>
</head>

<body>

    <div id="ui-container">
        <!-- ç‹€æ…‹åˆ— -->
        <div class="status-bar">
            <div class="life-container">
                LIVES: <span id="life-text">â¤â¤â¤</span>
            </div>
            <div class="score-container">
                <div class="score-label">SCORE</div>
                <div class="score-value" id="score-text">0</div>
                <div class="combo-text" id="combo-text">COMBO x1.2!</div>
            </div>
            <a href="help.html" class="help-link">HELP / éŠæˆ²ä»‹ç´¹</a>
        </div>

        <!-- é¡Œç›® -->
        <div id="question-box">
            <div id="question-text">Loading...</div>
        </div>

        <!-- ç­”æ¡ˆé¸é … -->
        <div id="answers-container">
            <div id="ans-0" class="answer-card" data-idx="0"><span class="option-num">A</span>
                <div class="fill-overlay"></div><span class="text">Option A</span>
            </div>
            <div id="ans-1" class="answer-card" data-idx="1"><span class="option-num">B</span>
                <div class="fill-overlay"></div><span class="text">Option B</span>
            </div>
            <div id="ans-2" class="answer-card" data-idx="2"><span class="option-num">C</span>
                <div class="fill-overlay"></div><span class="text">Option C</span>
            </div>
            <div id="ans-3" class="answer-card" data-idx="3"><span class="option-num">D</span>
                <div class="fill-overlay"></div><span class="text">Option D</span>
            </div>
        </div>
    </div>

    <!-- è©³è§£è¦–çª— -->
    <div id="feedback-modal" class="modal">
        <div id="feedback-title" class="modal-title">TITLE</div>
        <div id="feedback-content" class="modal-content">Explanation...</div>
    </div>

    <!-- çµç®—è¦–çª— -->
    <div id="gameover-modal" class="modal">
        <div class="modal-title" style="color:var(--primary)">GAME OVER</div>
        <div class="modal-content">
            <p>æœ€çµ‚å¾—åˆ†</p>
            <div style="font-size: 3rem; color: #fff; font-weight: bold; font-family: 'Orbitron';" id="final-score">0
            </div>
        </div>
        <!-- é€™æ˜¯ç¬¬ 5 å€‹äº’å‹•ç›®æ¨™ (Index 4) -->
        <div id="restart-btn" class="restart-btn">
            é‡æ–°æŒ‘æˆ°
            <div class="fill-overlay"></div>
        </div>
        <div style="margin-top: 15px; font-size: 0.9rem; color: #aaa;">
            è«‹å°é¡é ­æ¯”å‡º <span style="color:#fff; font-weight:bold; font-size: 1.2rem;">ğŸ–ï¸ (5)</span>
        </div>
    </div>

    <!-- é¡¯ç¤ºæ”å½±æ©Ÿç•«é¢ (å³ä¸‹è§’) -->
    <video id="input-video"></video>
    <canvas id="stage"></canvas>

    <script>
        let QUIZ_DATA = [];      // åŸå§‹é¡Œåº«
        let SHUFFLED_QUIZ = [];  // æ´—ç‰Œå¾Œçš„é¡Œåº«

        // --- 1. éŠæˆ²ç‹€æ…‹çµæ§‹ ---
        const GameState = {
            state: 'loading',       // 'loading', 'playing', 'feedback', 'gameover'
            questionIndex: 0,

            // éŠæˆ²æ•¸å€¼
            lives: 3,
            score: 0,
            streak: 0,
            questionStartTime: 0,

            // æ‰‹å‹¢è­˜åˆ¥ (Finger Counting)
            detectedCount: 0,       // ç›®å‰æ¯å¹€åµæ¸¬åˆ°çš„æ•¸é‡
            confirmedCount: 0,      // ç¢ºèªç©©å®šçš„æ•¸é‡
            lastCountTime: 0,       // ä¸Šæ¬¡æ•¸é‡è®ŠåŒ–çš„æ™‚é–“
            stableTime: 0,          // æŒçºŒç©©å®šçš„æ™‚é–“ accumulate

            chosenAnswer: -1,       // é–å®šçš„ç­”æ¡ˆ (0~3)
            selectionProgress: 0,   // 0.0 ~ 1.0 (é›†æ°£é€²åº¦)

            // UI åº§æ¨™ç·©å­˜ (ç”¨æ–¼ç²’å­å¸å¼•)
            targetRects: [],

            currentOptionMapping: []
        };

        // ... (CONFIG, particles, window.onload ä¿æŒä¸è®Š) ...

        const CONFIG = {
            particleCount: 15000,
            baseSpeed: 0.5,
            color: 'rgba(0, 242, 255, 0.8)',
            // ç¨å¾Œåœ¨ç²’å­é‚è¼¯ä¸­ä½¿ç”¨
        };

        let canvas, ctx, width, height;
        // ç§»é™¤åº§æ¨™ç›¸é—œ handX, handY, æ”¹ç”¨ fingerCount
        let currentFingerCount = 0;
        let isHandDetected = false;

        // ... (particles array init) ...
        const particles = {
            x: new Float32Array(CONFIG.particleCount),
            y: new Float32Array(CONFIG.particleCount),
            vx: new Float32Array(CONFIG.particleCount),
            vy: new Float32Array(CONFIG.particleCount),
            originVx: new Float32Array(CONFIG.particleCount),
            originVy: new Float32Array(CONFIG.particleCount)
        };

        // ... (loadCSV, parseCSV, startGame ä¿æŒä¸è®Š) ...

        // --- 3. åˆå§‹åŒ– ---
        window.onload = async function () {
            canvas = document.getElementById('stage');
            ctx = canvas.getContext('2d', { alpha: false });
            resize();
            initParticles();
            initMediaPipe();

            await loadCSV();

            window.addEventListener('resize', resize);
            requestAnimationFrame(loop);
        };

        async function loadCSV() {
            const statusEl = document.getElementById('question-text');
            try {
                statusEl.textContent = "è®€å–é¡Œåº«ä¸­...";
                const response = await fetch('questions.csv');
                if (!response.ok) throw new Error("File error");
                const text = await response.text();
                parseCSV(text);
                startGame();
            } catch (err) {
                console.error(err);
                statusEl.textContent = "CSV Error: " + err.message;
            }
        }

        function parseCSV(text) {
            const lines = text.trim().split(/\r?\n/);
            QUIZ_DATA = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const parts = [];
                let current = '', inQuote = false;
                for (let char of line) {
                    if (char === '"') inQuote = !inQuote;
                    else if (char === ',' && !inQuote) { parts.push(current); current = ''; }
                    else current += char;
                }
                parts.push(current);
                const clean = parts.map(p => p.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));
                if (clean.length >= 7) {
                    QUIZ_DATA.push({
                        question: clean[0],
                        options: [clean[1], clean[2], clean[3], clean[4]],
                        answer: parseInt(clean[5]) - 1,
                        explanation: clean[6]
                    });
                }
            }
        }

        function initParticles() {
            for (let i = 0; i < CONFIG.particleCount; i++) {
                particles.x[i] = Math.random() * width;
                particles.y[i] = Math.random() * height;
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * 0.5 + 0.2;
                particles.originVx[i] = Math.cos(a) * s;
                particles.originVy[i] = Math.sin(a) * s;
                particles.vx[i] = particles.originVx[i];
                particles.vy[i] = particles.originVy[i];
            }
        }

        // --- 4. éŠæˆ²æµç¨‹æ§åˆ¶ ---

        function startGame() {
            // é‡ç½®ç‹€æ…‹
            GameState.score = 0;
            GameState.lives = 3;
            GameState.streak = 0;
            GameState.questionIndex = 0;

            // éš¨æ©Ÿæ‰“äº‚é¡Œåº«é †åº (Shuffle)
            SHUFFLED_QUIZ = [...QUIZ_DATA].sort(() => Math.random() - 0.5);

            updateUI();

            document.getElementById('gameover-modal').classList.remove('visible');
            loadQuestion(0);
        }

        function loadQuestion(idx) {
            if (idx >= SHUFFLED_QUIZ.length) {
                // é¡Œç›®å…¨åšå®Œäº† -> éŠæˆ²çµæŸ
                endGame();
                return;
            }

            GameState.state = 'playing';
            GameState.questionIndex = idx;
            GameState.questionStartTime = Date.now();
            GameState.selectionProgress = 0;
            GameState.confirmedCount = 0;
            GameState.chosenAnswer = -1;

            const q = SHUFFLED_QUIZ[idx];

            // éš¨æ©Ÿæ’åˆ—é¸é … (Option Shuffle)
            // å»ºç«‹ä¸€å€‹ç´¢å¼•é™£åˆ— [0, 1, 2, 3] ä¸¦æ‰“äº‚
            const indices = [0, 1, 2, 3].sort(() => Math.random() - 0.5);
            GameState.currentOptionMapping = indices;

            // UI æ›´æ–°
            const box = document.getElementById('question-box');
            box.classList.remove('visible');

            // é‡ç½®é¸é …å¡æ¨£å¼
            for (let i = 0; i < 4; i++) {
                const el = document.getElementById('ans-' + i);
                el.className = 'answer-card';
                el.querySelector('.fill-overlay').style.width = '0%';

                // æ ¹æ“šæ‰“äº‚å¾Œçš„ç´¢å¼•å¡«å…¥æ–‡å­—
                // UI çš„ i å°æ‡‰åˆ° è³‡æ–™çš„ indices[i]
                el.querySelector('.text').textContent = q.options[indices[i]];
            }

            setTimeout(() => {
                document.getElementById('question-text').textContent = q.question;
                box.classList.add('visible');
                updateInteractRects();
            }, 500);
        }

        function checkAnswer(uiIndex) {
            GameState.state = 'feedback';
            const q = SHUFFLED_QUIZ[GameState.questionIndex];

            // é€é Mapping å°ç…§å›åŸå§‹ç­”æ¡ˆç´¢å¼•
            // UI é¸äº† uiIndexï¼Œä»£è¡¨åŸå§‹è³‡æ–™çš„ indices[uiIndex]
            const originalIndex = GameState.currentOptionMapping[uiIndex];
            const isCorrect = (originalIndex === q.answer);

            const selectedEl = document.getElementById('ans-' + uiIndex);

            if (isCorrect) {
                // --- ç­”å° ---
                selectedEl.classList.add('correct');

                // è¨ˆç®—åˆ†æ•¸
                const timeSpent = (Date.now() - GameState.questionStartTime) / 1000;
                let timeBonus = 0;
                if (timeSpent < 5) timeBonus = 500;
                else if (timeSpent < 10) timeBonus = 200;

                GameState.streak++;
                let streakMult = 1.0 + (GameState.streak * 0.1); // x1.2, x1.3...

                const points = Math.floor((1000 + timeBonus) * streakMult);
                GameState.score += points;

                updateUI();
                playFeedback(true, "ç­”å°äº†ï¼", `+${points} åˆ†`);

                setTimeout(() => {
                    closeFeedback();
                    loadQuestion(GameState.questionIndex + 1);
                }, 2000);

            } else {
                // --- ç­”éŒ¯ ---
                selectedEl.classList.add('wrong');

                // æ‰¾å‡ºæ­£ç¢ºé¸é …ä¸¦æ¨™ç¤º
                // å°‹æ‰¾ mapping ä¸­å“ªå€‹ UI index å°æ‡‰åˆ° q.answer
                const correctUIIndex = GameState.currentOptionMapping.indexOf(q.answer);
                document.getElementById('ans-' + correctUIIndex).classList.add('correct');

                GameState.lives--;
                GameState.streak = 0;
                updateUI();

                playFeedback(false, "ç­”éŒ¯äº†ï¼", q.explanation);

                const nextDelay = 5000;
                setTimeout(() => {
                    closeFeedback();
                    if (GameState.lives <= 0) {
                        endGame();
                    } else {
                        loadQuestion(GameState.questionIndex + 1);
                    }
                }, nextDelay);
            }
        }

        function endGame() {
            GameState.state = 'gameover';
            document.getElementById('final-score').textContent = GameState.score;
            document.getElementById('gameover-modal').classList.add('visible');
            updateInteractRects(); // ç¢ºä¿é‡æ–°æŠ“å–ã€Œé‡ç©æŒ‰éˆ•ã€çš„åº§æ¨™
        }

        function updateUI() {
            // ç”Ÿå‘½å€¼ (Hearts)
            let hearts = "";
            for (let i = 0; i < GameState.lives; i++) hearts += "â¤";
            document.getElementById('life-text').textContent = hearts;

            // åˆ†æ•¸
            document.getElementById('score-text').textContent = GameState.score;

            // Combo
            const comboEl = document.getElementById('combo-text');
            if (GameState.streak > 1) {
                comboEl.textContent = `COMBO x${(1.0 + GameState.streak * 0.1).toFixed(1)}!`;
                comboEl.classList.add('visible');
            } else {
                comboEl.classList.remove('visible');
            }
        }

        function playFeedback(isCorrect, title, content) {
            const modal = document.getElementById('feedback-modal');
            const tEl = document.getElementById('feedback-title');
            const cEl = document.getElementById('feedback-content');

            modal.className = 'modal visible ' + (isCorrect ? 'correct-mode' : 'wrong-mode');
            tEl.textContent = title;
            tEl.style.color = isCorrect ? 'var(--correct)' : 'var(--wrong)';
            cEl.textContent = content;
        }

        function closeFeedback() {
            document.getElementById('feedback-modal').className = 'modal';
        }

        // --- 5. äº’å‹•èˆ‡è¿´åœˆ ---

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            updateInteractRects();
        }

        function updateInteractRects() {
            GameState.targetRects = [];
            for (let i = 0; i < 4; i++) {
                const el = document.getElementById('ans-' + i);
                if (el && el.offsetParent !== null) {
                    GameState.targetRects.push(el.getBoundingClientRect());
                } else {
                    GameState.targetRects.push(null);
                }
            }
        }

        // --- 5. ä¸»å¾ªç’° (é‡å¯«é‚è¼¯) ---

        // --- 5. ä¸»å¾ªç’° (Finger Counting Logic) ---

        function loop() {
            // å¹³æ»‘æ‰‹æŒ‡è¨ˆæ•¸é‚è¼¯
            if (currentFingerCount !== GameState.detectedCount) {
                GameState.detectedCount = currentFingerCount;
                GameState.lastCountTime = Date.now();
            }

            const stableDuration = Date.now() - GameState.lastCountTime;

            // ç‹€æ…‹æ©Ÿ: ç­”é¡Œä¸­
            if (GameState.state === 'playing') {
                // å¿…é ˆç©©å®š 300ms æ‰ç®—ç¢ºèªè©²æ‰‹å‹¢ (é˜²é–ƒçˆ)
                // 1~4 æ ¹æ‰‹æŒ‡å°æ‡‰ 0~3 (A~D)
                if (stableDuration > 300 && GameState.detectedCount >= 1 && GameState.detectedCount <= 4) {
                    const targetIndex = GameState.detectedCount - 1;

                    if (GameState.chosenAnswer !== targetIndex) {
                        // æ›ç­”æ¡ˆäº†ï¼Œé‡ç½®é€²åº¦
                        GameState.chosenAnswer = targetIndex;
                        GameState.selectionProgress = 0;
                        document.querySelectorAll('.answer-card').forEach(el => el.classList.remove('hovering'));
                        document.querySelectorAll('.fill-overlay').forEach(el => el.style.width = '0%');
                    } else {
                        // åŒä¸€å€‹ç­”æ¡ˆï¼Œå¢åŠ é›†æ°£é€²åº¦
                        GameState.selectionProgress += 0.03; // ç´„ 0.5~1ç§’é›†æ»¿

                        // Visual Update
                        const el = document.getElementById('ans-' + targetIndex);
                        if (el) {
                            el.classList.add('hovering');
                            el.querySelector('.fill-overlay').style.width = Math.min(GameState.selectionProgress * 100, 100) + '%';
                        }

                        if (GameState.selectionProgress >= 1.0) {
                            checkAnswer(targetIndex);
                            // è§¸ç™¼å¾Œé‡ç½®ä»¥é˜²é€£çºŒè§¸ç™¼
                            GameState.chosenAnswer = -1;
                            GameState.selectionProgress = 0;
                        }
                    }
                } else {
                    // æ‰‹æŒ‡æ”¾é–‹ or 0 æ ¹ or ä¸ç©©å®š -> æ…¢æ…¢å°‡é€²åº¦æ­¸é›¶
                    if (GameState.selectionProgress > 0) {
                        GameState.selectionProgress -= 0.05;
                        if (GameState.selectionProgress <= 0) {
                            GameState.selectionProgress = 0;
                            GameState.chosenAnswer = -1;
                            document.querySelectorAll('.answer-card').forEach(el => el.classList.remove('hovering'));
                            document.querySelectorAll('.fill-overlay').forEach(el => el.style.width = '0%');
                        } else {
                            // è¦–è¦ºæ¶ˆé€€
                            if (GameState.chosenAnswer !== -1) {
                                document.querySelector(`#ans-${GameState.chosenAnswer} .fill-overlay`).style.width = (GameState.selectionProgress * 100) + '%';
                            }
                        }
                    }
                }
            }
            // ç‹€æ…‹æ©Ÿ: Game Over
            else if (GameState.state === 'gameover') {
                // åµæ¸¬ã€Œ5ã€(æ‰‹æŒ) ä¾†é‡ç©
                if (stableDuration > 500 && currentFingerCount === 5) {
                    GameState.selectionProgress += 0.02;
                    const btn = document.getElementById('restart-btn');
                    if (btn) btn.querySelector('.fill-overlay').style.width = Math.min(GameState.selectionProgress * 100, 100) + '%';

                    if (GameState.selectionProgress >= 1.0) {
                        startGame();
                    }
                } else {
                    GameState.selectionProgress = 0;
                    const btn = document.getElementById('restart-btn');
                    if (btn) btn.querySelector('.fill-overlay').style.width = '0%';
                }
            }

            updateParticles();
            draw();
            requestAnimationFrame(loop);
        }

        function updateParticles() {
            let tx = -1000, ty = -1000;
            let forceMult = 0;

            if (GameState.state === 'playing' && GameState.chosenAnswer !== -1) {
                const r = GameState.targetRects[GameState.chosenAnswer];
                if (r) {
                    tx = r.left + r.width / 2;
                    ty = r.top + r.height / 2;
                    forceMult = 5.0; // å¼·åŠ›å¸å¼•åˆ°å¡ç‰‡
                }
            } else if (GameState.state === 'gameover' && GameState.selectionProgress > 0) {
                const btn = document.getElementById('restart-btn');
                if (btn) {
                    const r = btn.getBoundingClientRect();
                    tx = r.left + r.width / 2;
                    ty = r.top + r.height / 2;
                    forceMult = 5.0;
                }
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let pvx = particles.vx[i], pvy = particles.vy[i];
                let px = particles.x[i], py = particles.y[i];

                if (forceMult > 0 && isHandDetected) {
                    const dx = tx - px, dy = ty - py;
                    const dSq = dx * dx + dy * dy;
                    if (dSq < CONFIG.interactionRadiusSq * 2 && dSq > 100) {
                        const f = (1 - dSq / (CONFIG.interactionRadiusSq * 2)) * 0.002 * forceMult;
                        pvx += dx * f;
                        pvy += dy * f;
                    }
                }

                pvx *= 0.95; pvy *= 0.95;
                pvx += particles.originVx[i] * 0.05; pvy += particles.originVy[i] * 0.05;

                particles.x[i] += pvx; particles.y[i] += pvy;
                if (particles.x[i] < 0) particles.x[i] = width; else if (particles.x[i] > width) particles.x[i] = 0;
                if (particles.y[i] < 0) particles.y[i] = height; else if (particles.y[i] > height) particles.y[i] = 0;

                particles.vx[i] = pvx; particles.vy[i] = pvy;
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(5, 5, 10, 0.3)';
            ctx.fillRect(0, 0, width, height);

            ctx.fillStyle = CONFIG.color;
            if (GameState.chosenAnswer !== -1) ctx.fillStyle = '#00ffcc';

            for (let i = 0; i < CONFIG.particleCount; i++) {
                ctx.fillRect(~~particles.x[i], ~~particles.y[i], 1, 1);
            }

            // ä¸­å¤®é¡¯ç¤ºç•¶å‰æ‰‹å‹¢æç¤º
            if (isHandDetected && GameState.state === 'playing') {
                ctx.font = "bold 80px Orbitron";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "rgba(255, 255, 255, 0.2)";

                let text = "";
                if (currentFingerCount === 1) text = "A";
                else if (currentFingerCount === 2) text = "B";
                else if (currentFingerCount === 3) text = "C";
                else if (currentFingerCount === 4) text = "D";

                if (text) {
                    // é¡¯ç¤ºæ–‡å­—
                    ctx.fillText(text, width / 2, height / 2);

                    // ç•«å€‹å¤–åœˆ
                    ctx.beginPath();
                    ctx.arc(width / 2, height / 2, 60, 0, Math.PI * 2);
                    ctx.strokeStyle = "rgba(0, 242, 255, 0.3)";
                    ctx.lineWidth = 5;
                    ctx.stroke();

                    // ç•«é€²åº¦åœˆ (Progress Ring)
                    if (GameState.selectionProgress > 0) {
                        const startAngle = -Math.PI / 2;
                        const endAngle = startAngle + (Math.PI * 2 * GameState.selectionProgress);
                        ctx.beginPath();
                        ctx.arc(width / 2, height / 2, 60, startAngle, endAngle);
                        ctx.strokeStyle = "#00f2ff";
                        ctx.lineWidth = 8;
                        ctx.stroke();
                    }
                }
            }
        }

        // --- 6. MediaPipe ---
        function initMediaPipe() {
            const v = document.getElementById('input-video');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(onHandsResults);
            new Camera(v, { onFrame: async () => await hands.send({ image: v }), width: 640, height: 480 }).start();
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                currentFingerCount = countFingers(landmarks);
            } else {
                isHandDetected = false;
                currentFingerCount = 0;
            }
        }

        function countFingers(lm) {
            let count = 0;
            // æ‹‡æŒ‡ (Thumb) åˆ¤å®š
            // æª¢æŸ¥æ‹‡æŒ‡æŒ‡å°– (4) æ˜¯å¦é é›¢é£ŸæŒ‡æŒ‡ç¯€ (5)
            // é€™æ˜¯åˆ¤æ–·æ‹‡æŒ‡æ˜¯å¦å¼µé–‹çš„ç›¸å°ç©©å¥æ–¹æ³•
            const distThumb = Math.hypot(lm[4].x - lm[17].x, lm[4].y - lm[17].y);
            const distIndex = Math.hypot(lm[5].x - lm[17].x, lm[5].y - lm[17].y);

            // å¦‚æœæ‹‡æŒ‡å°–è·é›¢å°æŒ‡æ ¹éƒ¨ æ¯” é£ŸæŒ‡æ ¹éƒ¨è·é›¢å°æŒ‡æ ¹éƒ¨ é‚„è¦é  1.2 å€ä»¥ä¸Šï¼Œé€šå¸¸ä»£è¡¨å¼µé–‹
            if (distThumb > distIndex * 1.2) count++;

            // é£ŸæŒ‡: 8 < 6
            if (lm[8].y < lm[6].y) count++;
            // ä¸­æŒ‡: 12 < 10
            if (lm[12].y < lm[10].y) count++;
            // ç„¡åæŒ‡: 16 < 14
            if (lm[16].y < lm[14].y) count++;
            // å°æŒ‡: 20 < 18
            if (lm[20].y < lm[18].y) count++;

            return count;
        }


    </script>
</body>

</html>